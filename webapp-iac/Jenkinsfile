pipeline {
  agent any

  parameters {
    choice(name: 'ENV', choices: ['dev', 'staging', 'prod'], description: 'Select Environment')
    choice(name: 'ACTION', choices: ['apply', 'destroy'], description: 'Select Terraform Action')
  }

  environment {
    AWS_CREDENTIALS = "aws-dev-iam"   // <-- your Jenkins credential ID
    REGION          = "ap-south-1"
    BASE_DIR        = "webapp-iac/envs"
  }

  stages {

    stage("Show Selection") {
      steps {
        script {
          echo """
          ‚úÖ Environment : ${ENV}
          üîß Action      : ${ACTION}
          üìÇ Directory   : ${BASE_DIR}/${ENV}
          üßæ Var File    : ${ENV}.tfvars
          """
        }
      }
    }

    stage("Terraform Init + Validate") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            sh """
              set -e
              terraform init -input=false
              terraform validate
            """
          }
        }
      }
    }

    stage("Terraform Plan (with SG self-heal)") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            // --- Preflight: import existing SG to avoid InvalidGroup.Duplicate ---
            sh """
              set -e

              SG_NAME="webapp-${ENV}-web-sg"

              # Try to read VPC and Subnet from tfvars (both optional in case your module derives them)
              VPC_ID=\$(awk -F= '/^\\s*vpc_id\\s*=/{print \$2}' ${ENV}.tfvars | tr -d ' "')
              SUBNET_ID=\$(awk -F= '/^\\s*subnet_id\\s*=/{print \$2}' ${ENV}.tfvars | tr -d ' "')

              if [ -z "\$VPC_ID" ] && [ -n "\$SUBNET_ID" ]; then
                echo "‚ÑπÔ∏è vpc_id not found in tfvars; deriving from subnet \$SUBNET_ID"
                VPC_ID=\$(aws ec2 describe-subnets --subnet-ids "\$SUBNET_ID" --region ${REGION} --query 'Subnets[0].VpcId' --output text 2>/dev/null || true)
              fi

              if [ -n "\$VPC_ID" ]; then
                EXISTING_SG=\$(aws ec2 describe-security-groups \
                  --region ${REGION} \
                  --filters "Name=vpc-id,Values=\$VPC_ID" "Name=group-name,Values=\$SG_NAME" \
                  --query 'SecurityGroups[0].GroupId' --output text 2>/dev/null || true)

                if [ "\$EXISTING_SG" != "None" ] && [ -n "\$EXISTING_SG" ]; then
                  echo "üîé Found existing SG \$SG_NAME in \$VPC_ID: \$EXISTING_SG"
                  if ! terraform state show module.web.aws_security_group.web >/dev/null 2>&1; then
                    echo "üì• Importing SG into Terraform state..."
                    terraform import 'module.web.aws_security_group.web' "\$EXISTING_SG" || true
                  else
                    echo "‚ÑπÔ∏è SG already tracked in state."
                  fi
                else
                  echo "‚úÖ No pre-existing SG named \$SG_NAME in VPC \$VPC_ID"
                fi
              else
                echo "‚ÑπÔ∏è Could not determine VPC_ID (no vpc_id/subnet_id in tfvars). Skipping SG pre-import."
              fi

              # Now generate a fresh plan that reflects any import we just did
              terraform plan -var-file=${ENV}.tfvars -out=tfplan.bin
            """
          }
        }
      }
    }

    stage("Approval for Destroy (Safety Gate)") {
      when { expression { params.ACTION == "destroy" } }
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          input(message: "‚ö†Ô∏è WARNING: Destroying ${ENV} environment. Proceed?")
        }
      }
    }

    stage("Apply / Destroy") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            script {
              if (ACTION == "destroy") {
                echo "üî• Starting Safe Destroy sequence..."

                // Phase 1: Destroy EC2 instance(s)
                sh """
                  set -e
                  echo "üßπ Phase 1: Destroying EC2 instance(s)..."
                  terraform destroy -auto-approve -target=module.web.aws_instance.web -var-file=${ENV}.tfvars || echo "‚ö†Ô∏è Instance destroy skipped (not found)"
                """

                // Phase 2: Wait for ENIs to detach from SG (best-effort)
                sh """
                  set +e
                  echo "‚è≥ Checking for attached ENIs..."
                  SG_ID=\$(terraform state show module.web.aws_security_group.web 2>/dev/null | awk '/^id =/ {print \$3}')
                  if [ -n "\$SG_ID" ]; then
                    echo "üîç Found SG ID: \$SG_ID"
                    for i in {1..18}; do
                      ENI_COUNT=\$(aws ec2 describe-network-interfaces --filters "Name=group-id,Values=\$SG_ID" --region ${REGION} --query 'NetworkInterfaces' | jq length 2>/dev/null)
                      if [ -z "\$ENI_COUNT" ]; then ENI_COUNT=0; fi
                      if [ "\$ENI_COUNT" -eq 0 ]; then
                        echo "‚úÖ ENIs detached ‚Äî safe to delete SG"
                        break
                      fi
                      echo "‚è≥ ENIs still attached... retrying in 15s"
                      sleep 15
                    done
                  else
                    echo "‚ÑπÔ∏è SG not found in state or already deleted."
                  fi
                """

                // Phase 3: Destroy SG with retries
                sh """
                  set +e
                  echo "üßπ Phase 3: Destroying Security Group..."
                  for i in {1..3}; do
                    terraform destroy -auto-approve -target=module.web.aws_security_group.web -var-file=${ENV}.tfvars && break || echo "‚ö†Ô∏è Retry SG destroy (attempt \$i)..."
                    sleep 10
                  done
                """

                // Phase 4: Final cleanup
                sh """
                  set +e
                  terraform destroy -auto-approve -var-file=${ENV}.tfvars || echo "‚úÖ Cleanup complete or already destroyed"
                """

              } else {
                echo "üöÄ Applying Terraform configuration..."
                // Apply the exact plan created in Plan stage
                sh """
                  set -e
                  terraform apply -auto-approve tfplan.bin
                """
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "‚úÖ Pipeline finished."
    }
    success {
      script {
        if (ACTION == "apply") {
          withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
            dir("${BASE_DIR}/${ENV}") {
              def ip = sh(script: "terraform output -raw web_public_ip || echo 'N/A'", returnStdout: true).trim()
              echo "üåç Server Public IP: ${ip}"
              echo "üíª SSH Command: ssh ubuntu@${ip}"
            }
          }
        }
      }
    }
    failure {
      echo "‚ùå Pipeline failed ‚Äî check above logs for Terraform or AWS errors."
    }
  }
}
