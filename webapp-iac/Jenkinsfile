pipeline {
  agent any

  parameters {
    choice(name: 'ENV', choices: ['dev', 'staging', 'prod'], description: 'Select environment')
    choice(name: 'ACTION', choices: ['APPLY', 'DESTROY'], description: 'Apply or Destroy infra')
  }

  environment {
    AWS_CRED  = 'aws-dev-iam'               // Jenkins credential ID
    AWS_REGION = 'ap-south-1'
    ENV_DIR   = "webapp-iac/envs/${params.ENV}"
    VAR_FILE  = "${params.ENV}.tfvars"
  }

  stages {

    stage('Show Selection') {
      steps {
        echo """
        âœ… Environment : ${params.ENV}
        ğŸ”§ Action      : ${params.ACTION}
        ğŸ“‚ Directory   : ${ENV_DIR}
        ğŸ§¾ Var File    : ${VAR_FILE}
        """
      }
    }

    stage('Terraform Init + Validate') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh '''
              set -e
              terraform init
              terraform validate
            '''
          }
        }
      }
    }

    // Avoid duplicate SG create errors when APPLYing and SG already exists
    stage('Import Existing SG (avoid duplicate SG error)') {
      when { expression { params.ACTION == 'APPLY' } }
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              def sgName = "webapp-${params.ENV}-web-sg"
              echo "ğŸ” Checking for existing SG: ${sgName}"
              def existing = sh(script: "aws ec2 describe-security-groups --filters Name=group-name,Values=${sgName} --query SecurityGroups[0].GroupId --output text", returnStdout: true).trim()
              if (existing != "None" && existing) {
                echo "âœ… Importing existing SG into state: ${existing}"
                // Import may need vars; tolerate non-zero exit to keep pipeline going
                sh "terraform import -input=false module.web.aws_security_group.web ${existing} || true"
              } else {
                echo "â„¹ï¸ No existing SG found."
              }
            }
          }
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh "terraform plan -var-file=${VAR_FILE} -out=tfplan.bin"
          }
        }
      }
    }

    stage('Approval for Destroy (Safety Gate)') {
      when { expression { params.ACTION == 'DESTROY' } }
      steps {
        timeout(time: 60, unit: 'SECONDS') {
          input message: "âš ï¸ WARNING: Destroying ${params.ENV} environment. Proceed?"
        }
      }
    }

    stage('Apply / Destroy') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              if (params.ACTION == 'APPLY') {
                sh "terraform apply -auto-approve tfplan.bin"
              } else {
                // ---- Robust 2-phase destroy ----
                // Phase 1: Destroy instance(s)
                sh """
                  set -e
                  echo "ğŸ§¹ Phase 1: Destroy instances..."
                  terraform destroy -auto-approve -target=module.web.aws_instance.web -var-file=${VAR_FILE} || true
                """

                // Wait until ENIs using the SG are gone (DependencyViolation workaround)
                sh '''
                  echo "â³ Waiting for ENIs to detach from SG before deleting SG..."
                  # Try to read SG ID from state; if missing, skip wait
                  SG_ID=$(terraform state show module.web.aws_security_group.web 2>/dev/null | awk \'/^id = /{print $3}\')
                  if [ -n "$SG_ID" ]; then
                    for i in $(seq 1 60); do
                      ENI=$(aws ec2 describe-network-interfaces --filters Name=group-id,Values=$SG_ID --query "NetworkInterfaces[0].NetworkInterfaceId" --output text || echo "None")
                      if [ "$ENI" = "None" ]; then
                        echo "âœ… No ENIs attached to $SG_ID. Proceeding."
                        break
                      fi
                      echo "â³ ENI still attached ($ENI). Waiting 10s... ($i/60)"
                      sleep 10
                    done
                  else
                    echo "â„¹ï¸ SG not in state (already gone or never managed)."
                  fi
                '''

                // Phase 2: Destroy the SG
                sh """
                  echo "ğŸ§¹ Phase 2: Destroy Security Group..."
                  terraform destroy -auto-approve -target=module.web.aws_security_group.web -var-file=${VAR_FILE} || true
                  echo "ğŸ§¹ Final sweep: destroy anything remaining..."
                  terraform destroy -auto-approve -var-file=${VAR_FILE} || true
                """
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "âœ… Pipeline finished."
      // Only try to print outputs for APPLY; DESTROY has no outputs by design
      script {
        if (params.ACTION == 'APPLY') {
          withAWS(credentials: AWS_CRED, region: AWS_REGION) {
            dir("${ENV_DIR}") {
              // Donâ€™t fail the build if output is absent; print nicely if present
              sh '''
                IP=$(terraform output -raw web_public_ip 2>/dev/null || true)
                if [ -n "$IP" ]; then
                  echo "ğŸŒ Server IP: $IP"
                  echo "ğŸ’» SSH Command: ssh ubuntu@$IP"
                else
                  echo "â„¹ï¸ No web_public_ip output available yet."
                fi
              '''
            }
          }
        } else {
          echo "ğŸ§¹ Destroy completed. Skipping outputs."
        }
      }
    }
  }
}
