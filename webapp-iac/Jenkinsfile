pipeline {
  agent any

  parameters {
    choice(name: 'TARGET_ENV', choices: ['dev', 'staging', 'prod'], description: 'Which environment to deploy?')
    choice(name: 'ACTION', choices: ['APPLY', 'DESTROY'], description: 'Terraform Action')
  }

  environment {
    AWS_REGION = "ap-south-1"
    AWS_CREDS  = "aws-dev-iam"        // your Jenkins AWS credential
    ENV_DIR    = "webapp-iac/envs/${params.TARGET_ENV}"
    VAR_FILE   = "${params.TARGET_ENV}.tfvars"
  }

  stages {

    stage('Show Selection') {
      steps {
        echo """
        âœ… Environment : ${params.TARGET_ENV}
        ðŸ”§ Action      : ${params.ACTION}
        ðŸ“‚ Directory   : ${ENV_DIR}
        ðŸ§¾ Var File    : ${VAR_FILE}
        """
      }
    }

    stage('Terraform Init + Validate') {
      steps {
        withAWS(credentials: AWS_CREDS, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh """
              set -e
              terraform init
              terraform validate
            """
          }
        }
      }
    }

    stage('Import Existing SG (avoid duplicate SG error)') {
      steps {
        withAWS(credentials: AWS_CREDS, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              def sgName = "webapp-${params.TARGET_ENV}-web-sg"
              sh """
                set -e
                echo "ðŸ”Ž Checking for existing SG: ${sgName}"
                EXISTING_SG_ID=\$(aws ec2 describe-security-groups \
                  --filters Name=group-name,Values=${sgName} \
                  --query 'SecurityGroups[0].GroupId' \
                  --output text 2>/dev/null || true)

                if [ "\$EXISTING_SG_ID" != "None" ] && [ -n "\$EXISTING_SG_ID" ]; then
                  echo "âœ… Importing SG into Terraform: \$EXISTING_SG_ID"
                  terraform import -input=false 'module.web.aws_security_group.web' "\$EXISTING_SG_ID" || true
                else
                  echo "â„¹ No existing SG found. Continue."
                fi
              """
            }
          }
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        withAWS(credentials: AWS_CREDS, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh "terraform plan -var-file=${VAR_FILE} -out=tfplan.bin"
          }
        }
      }
    }

    stage('Approval for Destroy (Safety Gate)') {
      when { expression { params.ACTION == "DESTROY" } }
      steps {
        input message: "âš  CONFIRM DESTROY for ${params.TARGET_ENV}? This will DELETE resources."
      }
    }

    stage('Apply / Destroy') {
      steps {
        withAWS(credentials: AWS_CREDS, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              if (params.ACTION == "APPLY") {
                sh "terraform apply -auto-approve tfplan.bin"
              } else {
                sh "terraform destroy -auto-approve -var-file=${VAR_FILE}"
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "âœ… Pipeline finished."
    }
  }
}
