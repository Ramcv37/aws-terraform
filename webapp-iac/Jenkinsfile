# Jenkinsfile
# CI/CD pipeline for multi-environment web app deployment
  pipeline {
  agent any
  options {
    timestamps()
    ansiColor('xterm')
  }

  environment {
    // Map branch -> environment dir + tfvars file
    TARGET_ENV = "${env.BRANCH_NAME == 'main' ? 'prod' : (env.BRANCH_NAME == 'staging' ? 'staging' : 'dev')}"
    ENV_DIR    = "envs/${env.TARGET_ENV}"
    VAR_FILE   = "${env.TARGET_ENV}.tfvars"
  }

  parameters {
    booleanParam(name: 'AUTO_APPROVE', defaultValue: true, description: 'Auto-approve apply/destroy')
    choice(name: 'ROLLBACK_MODE', choices: ['none','last_successful_commit','destroy_partial'], description: 'Rollback strategy after failures or on demand')
    booleanParam(name: 'ROLLBACK_ON_FAILURE', defaultValue: true, description: 'If apply fails, run rollback action')
  }

  stages {
    stage('Checkout') {
      steps {
        checkout scm
        script {
          echo "Branch: ${env.BRANCH_NAME}, Target env: ${env.TARGET_ENV}"
        }
      }
    }

    stage('Set AWS Credentials') {
      steps {
        script {
          // --- Option A: direct access keys per env (Secret Text credentials) ---
          withCredentials([
            string(credentialsId: "aws_access_key_id_${env.TARGET_ENV}", variable: 'AWS_ACCESS_KEY_ID'),
            string(credentialsId: "aws_secret_access_key_${env.TARGET_ENV}", variable: 'AWS_SECRET_ACCESS_KEY')
          ]) {
            sh 'aws sts get-caller-identity || true'
          }

          // --- Option B: AssumeRole (preferred) ---
          // withCredentials([
          //   string(credentialsId: "ci_aws_access_key_id",     variable: 'CI_AWS_ACCESS_KEY_ID'),
          //   string(credentialsId: "ci_aws_secret_access_key", variable: 'CI_AWS_SECRET_ACCESS_KEY')
          // ]) {
          //   sh '''
          //     export AWS_ACCESS_KEY_ID="$CI_AWS_ACCESS_KEY_ID"
          //     export AWS_SECRET_ACCESS_KEY="$CI_AWS_SECRET_ACCESS_KEY"
          //     CREDS=$(aws sts assume-role --role-arn arn:aws:iam::<ACCOUNT_ID>:role/terraform-${TARGET_ENV} --role-session-name jenkins-${TARGET_ENV} --duration-seconds 3600)
          //     export AWS_ACCESS_KEY_ID=$(echo "$CREDS" | jq -r .Credentials.AccessKeyId)
          //     export AWS_SECRET_ACCESS_KEY=$(echo "$CREDS" | jq -r .Credentials.SecretAccessKey)
          //     export AWS_SESSION_TOKEN=$(echo "$CREDS" | jq -r .Credentials.SessionToken)
          //     aws sts get-caller-identity
          //   '''
          // }
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir("${ENV_DIR}") {
          sh '''
            terraform --version
            terraform init -reconfigure \
              -backend-config=backend.hcl
          '''
        }
      }
    }

    stage('Validate & Plan') {
      steps {
        dir("${ENV_DIR}") {
          sh '''
            terraform validate
            terraform plan -var-file=${VAR_FILE} -out=tfplan.bin
          '''
        }
      }
      post {
        success {
          archiveArtifacts artifacts: "${ENV_DIR}/tfplan.bin", onlyIfSuccessful: true
        }
      }
    }

    stage('Apply') {
      when { expression { return params.AUTO_APPROVE } }
      steps {
        dir("${ENV_DIR}") {
          sh '''
            set -e
            terraform apply -auto-approve tfplan.bin
          '''
        }
      }
    }
  }

  post {
    success {
      script {
        echo "✅ Deployment successful for ${env.TARGET_ENV}"
      }
    }
    failure {
      script {
        echo "❌ Pipeline failed on ${env.TARGET_ENV}"
        if (params.ROLLBACK_ON_FAILURE && params.ROLLBACK_MODE != 'none') {
          echo "Running rollback mode: ${params.ROLLBACK_MODE}"
          try {
            if (params.ROLLBACK_MODE == 'last_successful_commit') {
              // 1) Re-apply last green git revision
              def prev = env.GIT_PREVIOUS_SUCCESSFUL_COMMIT ?: ''
              if (prev?.trim()) {
                dir('rollback-last-success') {
                  // Check out that good commit into a temp dir
                  sh """
                    git clone ${env.GIT_URL} .
                    git checkout ${prev}
                    cd ${ENV_DIR}
                    terraform init -reconfigure -backend-config=backend.hcl
                    terraform plan -var-file=${VAR_FILE} -out=tfplan.rollback.bin
                    terraform apply -auto-approve tfplan.rollback.bin
                  """
                }
              } else {
                echo "No previous successful commit available; skipping redeploy."
              }
            } else if (params.ROLLBACK_MODE == 'destroy_partial') {
              // 2) Tear down partially-created infra (use only for ephemeral stacks)
              dir("${ENV_DIR}") {
                sh """
                  terraform init -reconfigure -backend-config=backend.hcl
                  terraform destroy ${params.AUTO_APPROVE ? '-auto-approve' : ''} -var-file=${VAR_FILE}
                """
              }
            }
          } catch (err) {
            echo "Rollback action encountered an error: ${err}"
          }
        } else {
          echo "Rollback disabled or set to 'none'."
        }
      }
    }
    always {
      script {
        // Show some outputs if state exists
        sh """
          if [ -d "${ENV_DIR}" ]; then
            cd ${ENV_DIR}
            terraform output || true
          fi
        """
      }
    }
  }
}

