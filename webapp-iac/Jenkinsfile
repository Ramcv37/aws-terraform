pipeline {
  agent any

  parameters {
    choice(name: 'ENV', choices: ['dev', 'staging', 'prod'], description: 'Select environment to deploy')
    choice(name: 'ACTION', choices: ['APPLY', 'DESTROY'], description: 'Apply or Destroy infrastructure')
  }

  environment {
    AWS_CRED = "aws-dev-iam"            // Jenkins credential ID
    AWS_REGION = "ap-south-1"
    ENV_DIR = "webapp-iac/envs/${params.ENV}"
    VAR_FILE = "${params.ENV}.tfvars"
  }

  stages {

    stage('Show Selection') {
      steps {
        echo """
        ‚úÖ Environment : ${params.ENV}
        üîß Action      : ${params.ACTION}
        üìÇ Directory   : ${ENV_DIR}
        üßæ Var File    : ${VAR_FILE}
        """
      }
    }

    stage('Terraform Init + Validate') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh '''
              set -e
              terraform init
              terraform validate
            '''
          }
        }
      }
    }

    stage('Import Existing SG (avoid duplicate SG error)') {
      when { expression { params.ACTION == "APPLY" } }
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              def sgName = "webapp-${params.ENV}-web-sg"
              echo "üîé Checking for existing SG: ${sgName}"

              def existing = sh(script: "aws ec2 describe-security-groups --filters Name=group-name,Values=${sgName} --query SecurityGroups[0].GroupId --output text", returnStdout: true).trim()

              if(existing != "None" && existing != "") {
                echo "‚úÖ Importing existing SG: ${existing}"
                sh "terraform import -input=false module.web.aws_security_group.web ${existing} || true"
              } else {
                echo "‚ÑπÔ∏è No existing SG found. Continuing normally."
              }
            }
          }
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            sh "terraform plan -var-file=${VAR_FILE} -out=tfplan.bin"
          }
        }
      }
    }

    stage('Approval for Destroy (Safety Gate)') {
      when { expression { params.ACTION == "DESTROY" } }
      steps {
        timeout(time: 60, unit: 'SECONDS') {
          input message: "‚ö†Ô∏è WARNING: Destroying ${params.ENV} environment. Proceed?"
        }
      }
    }

    stage('Apply / Destroy') {
      steps {
        withAWS(credentials: AWS_CRED, region: AWS_REGION) {
          dir("${ENV_DIR}") {
            script {
              if(params.ACTION == "APPLY") {
                sh "terraform apply -auto-approve tfplan.bin"
              } else {
                sh "terraform destroy -auto-approve -var-file=${VAR_FILE}"
              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "‚úÖ Pipeline finished."

      withAWS(credentials: AWS_CRED, region: AWS_REGION) {
        dir("${ENV_DIR}") {
          script {
            try {
              def publicIP = sh(script: "terraform output -raw web_public_ip", returnStdout: true).trim()
              echo "üåç Server Public IP: ${publicIP}"
              echo "üíª SSH Command: ssh ubuntu@${publicIP}"
            } catch (e) {
              echo "‚ö†Ô∏è No public IP available."
            }
          }
        }
      }
    }
  }
}
