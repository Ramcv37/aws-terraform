pipeline {
  agent any
  options { timestamps() }

  parameters {
    booleanParam(name: 'AUTO_APPROVE', defaultValue: true, description: 'Auto-approve terraform apply')
  }

  stages {

    stage('Checkout') {
      steps {
        checkout scm
        script {
          // âœ… Map branch -> environment
          def target = (env.BRANCH_NAME == 'master') ? 'prod'
                    : (env.BRANCH_NAME == 'staging') ? 'staging'
                    : 'dev'

          env.TARGET_ENV = target
          env.ENV_DIR    = "envs/${target}"
          env.VAR_FILE   = "${target}.tfvars"

          echo "Branch: ${env.BRANCH_NAME}"
          echo "Deploying to Environment: ${env.TARGET_ENV}"
        }
      }
    }

    stage('AWS Credentials') {
      steps {
        withCredentials([
          string(credentialsId: "aws_access_key_id_${env.TARGET_ENV}", variable: 'AWS_ACCESS_KEY_ID'),
          string(credentialsId: "aws_secret_access_key_${env.TARGET_ENV}", variable: 'AWS_SECRET_ACCESS_KEY')
        ]) {
          withEnv(['AWS_DEFAULT_REGION=ap-south-1']) {
            sh 'aws sts get-caller-identity || true'
          }
        }
      }
    }

    stage('Terraform Init') {
      steps {
        dir("${env.ENV_DIR}") {
          sh '''
            terraform --version
            terraform init -reconfigure -backend-config=backend.hcl
          '''
        }
      }
    }

    stage('Terraform Plan') {
      steps {
        dir("${env.ENV_DIR}") {
          sh 'terraform validate'
          sh 'terraform plan -var-file=${VAR_FILE} -out=tfplan.bin'
        }
      }
    }

    stage('Terraform Apply') {
      when { expression { return params.AUTO_APPROVE } }
      steps {
        dir("${env.ENV_DIR}") {
          sh 'terraform apply -auto-approve tfplan.bin'
        }
      }
    }
  }

  post {
    always {
      sh '''
        if [ -d "${ENV_DIR}" ]; then
          cd "${ENV_DIR}" && terraform output || true
        fi
      '''
    }
  }
}
