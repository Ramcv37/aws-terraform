pipeline {
  agent any

  parameters {
    choice(name: 'ENV', choices: ['dev', 'staging', 'prod'], description: 'Select Environment')
    choice(name: 'ACTION', choices: ['apply', 'destroy'], description: 'Select Terraform Action')
  }

  environment {
    AWS_CREDENTIALS = "aws-creds"
    REGION = "ap-south-1"
    BASE_DIR = "webapp-iac/envs"
  }

  stages {

    stage("Show Selection") {
      steps {
        script {
          echo """
          ‚úÖ Environment : ${ENV}
          üîß Action      : ${ACTION}
          üìÇ Directory   : ${BASE_DIR}/${ENV}
          üßæ Var File    : ${ENV}.tfvars
          """
        }
      }
    }

    stage("Terraform Init + Validate") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            sh """
              terraform init
              terraform validate
            """
          }
        }
      }
    }

    stage("Terraform Plan") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            sh """
              terraform plan -var-file=${ENV}.tfvars -out=tfplan.bin
            """
          }
        }
      }
    }

    stage("Approval for Destroy (Safety Gate)") {
      when { expression { params.ACTION == "destroy" } }
      steps {
        timeout(time: 2, unit: 'MINUTES') {
          input(message: "‚ö†Ô∏è WARNING: Destroying ${ENV} environment. Proceed?")
        }
      }
    }

    stage("Apply / Destroy") {
      steps {
        withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
          dir("${BASE_DIR}/${ENV}") {
            script {

              if (ACTION == "destroy") {
                echo "üî• Phase 1: Destroy EC2 instance(s)..."
                sh """
                  terraform destroy -auto-approve -target=module.web.aws_instance.web -var-file=${ENV}.tfvars
                """

                echo "‚è≥ Waiting for ENIs to detach from SG before deleting SG..."
                sh """
                  SG_ID=\$(terraform state show module.web.aws_security_group.web 2>/dev/null | awk '/^id =/ {print \$3}')
                  if [ -n "\$SG_ID" ]; then
                    echo "üîç SG ID = \$SG_ID"
                    for i in {1..18}; do
                      ENI_COUNT=\$(aws ec2 describe-network-interfaces --filters "Name=group-id,Values=\$SG_ID" --region ${REGION} --query 'NetworkInterfaces' | jq length)
                      if [ "\$ENI_COUNT" -eq 0 ]; then
                        echo "‚úÖ No ENIs attached ‚Äî safe to delete SG."
                        break
                      fi
                      echo "‚è≥ ENI still attached... retrying in 20s"
                      sleep 20
                    done
                  else
                    echo "‚ÑπÔ∏è SG not in state (already gone or never managed)."
                  fi
                """

                echo "üßπ Phase 2: Destroy Security Group..."
                sh """
                  terraform destroy -auto-approve -target=module.web.aws_security_group.web -var-file=${ENV}.tfvars
                """

              } else {

                echo "üöÄ Applying Terraform..."
                sh """
                  terraform apply -auto-approve -var-file=${ENV}.tfvars
                """

              }
            }
          }
        }
      }
    }
  }

  post {
    always {
      echo "‚úÖ Pipeline finished."
    }

    success {
      script {
        if (ACTION == "apply") {
          withAWS(region: "${REGION}", credentials: "${AWS_CREDENTIALS}") {
            dir("${BASE_DIR}/${ENV}") {
              def ip = sh(script: "terraform output -raw web_public_ip || echo 'N/A'", returnStdout: true).trim()
              echo "üåç Server Public IP: ${ip}"
              echo "üíª SSH Command: ssh ubuntu@${ip}"
            }
          }
        }
      }
    }
  }
}
